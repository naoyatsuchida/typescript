"use strict";
/*
プリミティブ型・・真偽地や数値などの基本的な型で一度作成したらその値自体を変更できない・イミュータブルの特性がある
　真偽地
　数値
　巨大な整数
　文字列undefined
　null
　シンボル

オブジェクト型・・一度作成した後も変更可能ミュータブル。値そのもではなく、値へのアドレスへの参照を経由されるため参照型ともいわれる
  オブジェクト
  配列
  関数
  クラス
  正規表現
  Date

  typeofでデータ型が分かるのはプリミティブ型だけ。オブジェクトにtypeof []をしてもObjectと返却される
  nullがObjectと返されるのはバグ

リテラル・・プログラム上で数値や文字列など、データ型の値を直接記述できる
  真偽地
  数値
  ビックいんと
  文字列
  null


文字列でエスケープさせたいときは以下で表現ができる
"文章を書いていてい/n改行を入れたい"
`文章を書いていて
改行を入れたい`

nullの使い道は定義した段階では値がはいいていないことを明確化したい


ラッパーオブジェクト・・・プリミティブ型の値をラップしたようなオブジェクト
本来、let str = "hoge"; str.lengthのようなことはできない(プリミティブ型は純粋な値なので)
出来てしまう理由はstrにアクセスいようとした際、対応するオブジェクト(string)に変換しているから。

*/
const foo = null;
console.log(foo);

/*
演算子
二項演算子
+ 数値と文字列を結合できる
- 数値の減算ができる
* 数値の掛け算ができる
/ 数値の割り算ができる、、あまりなし
% 数値の余りを算出する
**　べき乗ができる2**4は16


=== この比較演算子で比較できるのはプリミティブ型のみ
{} === {} はfalseになる。オブジェクト型はそれぞれが別のオブジェクトを作成するため


^ ビット排他的論理和

 分割代入
let hoge = [2,4];
let [a,b] = ...hoge


let hoge = [2, 4];
let [a, b] = hoge;
console.log(a, b);


短絡評価
// 左辺はfalsyではないため、評価結果として右辺を返す
console.log("文字列" && "右辺の値"); // => "右辺の値"
console.log(42 && "右辺の値"); // => "右辺の値"
// 左辺がfalsyであるため、評価結果として左辺を返す
console.log("" && "右辺の値"); // => ""
console.log(0 && "右辺の値"); // => 0
console.log(null && "右辺の値"); // => null


Nullish coalescing演算子
??  左の値がnullかundefiedであれば右の値を返却する
使い道はなんやろ
0の場合は||では正の評価がされてしまうので??を追加して右の値を代入できるようにした

const inputValue = 任意の値または未定義;
// `inputValue`がfalsyの場合は、`value`には`42`が入る
// `inputValue`が`0`の場合は、`value`に`42`が入ってしまう
const value = inputValue || 42;
console.log(value);

*/
